#include <vector>
#include <utility>
#include <string>
#include <iostream>

class XMLProcess {
private:
    std::vector<std::pair<std::wstring, std::wstring>> xmlInfo;

public:
    void processNodePlus(IXMLDOMNode* pNode) {
        if (pNode == NULL) {
            return;
        }

        auto nodeInfo = RRTools::getNodeInfo(pNode);

        // Extrahieren des Knotennamens und des Knotenwerts
        BSTR nodeName, nodeValue;
        pNode->get_nodeName(&nodeName);
        pNode->get_text(&nodeValue);

        // Hinzufügen der Knoteninformationen zum Vektor
        xmlInfo.push_back({ nodeInfo.first, nodeValue });

        // Freigeben der Speicherressourcen
        SysFreeString(nodeName);
        SysFreeString(nodeValue);

        // Verarbeitung der Kindknoten
        IXMLDOMNodeList* pChildren;
        pNode->get_childNodes(&pChildren);
        long length;
        pChildren->get_length(&length);

        for (long i = 0; i < length; i++) {
            IXMLDOMNode* pChild;
            pChildren->get_item(i, &pChild);
            processNodePlus(pChild);
        }
    }

    int getNodeCount() const {
        return xmlInfo.size();
    }

    std::pair<std::wstring, std::wstring> getNodeInfo(int index) const {
        if (index >= 0 && index < xmlInfo.size()) {
            return xmlInfo[index];
        } else {
            return { L"", L"" }; // Rückgabe eines leeren Paares, wenn der Index ungültig ist
        }
    }

    const std::vector<std::pair<std::wstring, std::wstring>>& getXMLInfo() const {
        return xmlInfo;
    }
};


//----------------------

#include <memory>

class XMLProcess {
private:
    std::shared_ptr<IXMLDOMDocument> pXMLDom;

public:
    XMLProcess() : pXMLDom(nullptr) {}

    void loadXMLDocument(const std::wstring& filename) {
        HRESULT hr_com = CoInitialize(NULL);
        if (FAILED(hr_com)) {
            throw std::runtime_error("Fehler bei der Initialisierung der COM-Schnittstelle");
        }

        HRESULT hr = CoCreateInstance(__uuidof(DOMDocument60), NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&pXMLDom));
        if (FAILED(hr)) {
            CoUninitialize();
            throw std::runtime_error("Fehler beim Erstellen des XML-DOM-Objekts.");
        }

        VARIANT_BOOL status;
        VARIANT xmlSource;
        xmlSource.vt = VT_BSTR;
        xmlSource.bstrVal = SysAllocString(filename.c_str());
        hr = pXMLDom->load(xmlSource, &status);
        SysFreeString(xmlSource.bstrVal);

        if (FAILED(hr) || status != VARIANT_TRUE) {
            pXMLDom = nullptr;
            CoUninitialize();
            throw std::runtime_error("Fehler beim Laden der XML-Datei.");
        }
    }

    void processXMLDocument() {
        if (!pXMLDom) {
            throw std::runtime_error("XML-Dokument wurde nicht geladen.");
        }

        IXMLDOMElement* pRootNode;
        HRESULT hr = pXMLDom->get_documentElement(&pRootNode);
        if (FAILED(hr) || !pRootNode) {
            throw std::runtime_error("Fehler beim Abrufen des Wurzelknotens.");
        }

        // Hier können Sie Ihre Verarbeitungsfunktionen aufrufen
        // Beispiel: processNodePlus(pRootNode);

        pRootNode->Release();
    }
};
//>>>--------------------------------------------
... drei TDBGrid-Komponenten haben und nur eine davon mit einer Datenbank verbunden sein soll, benötigen Sie dennoch nur ein TDataset, um die Daten aus der Datenbank abzurufen, und ein TDBClientDataset, um die Daten für die anderen beiden TDBGrids bereitzustellen.
Hier ist eine typische Vorgehensweise:
    1. TDataset: Verwenden Sie eine TDataset-Komponente (z. B. TQuery, TTable, TStoredProc), um die Daten aus der Datenbank abzurufen. Diese Komponente ist direkt mit der Datenbank verbunden und liest oder schreibt Daten in die Datenbank.
    2. TDBClientDataset: Verwenden Sie eine TDBClientDataset-Komponente, um die Daten aus der TDataset zu speichern. Diese Komponente fungiert als Zwischenspeicher und ermöglicht es Ihnen, die Daten zu bearbeiten, zu filtern und zu sortieren, ohne direkte Auswirkungen auf die Datenbank.
    3. Datenbindung: Binden Sie die erste TDBGrid-Komponente direkt an die TDataset-Komponente, damit sie die Daten aus der Datenbank anzeigt.
    4. Kopieren der Daten: Verwenden Sie die TDBClientDataset-Komponente, um eine Kopie der Daten aus der Datenbank zu erstellen. Diese Kopie wird dann von den anderen beiden TDBGrids verwendet.
    5. Datenanzeige: Binden Sie die beiden anderen TDBGrids-Komponenten an die TDBClientDataset-Komponente, um die Daten anzuzeigen, die von der ersten TDBGrid angezeigt werden.
Auf diese Weise haben Sie nur ein TDataset, das direkt mit der Datenbank verbunden ist, und ein TDBClientDataset, das als Datenquelle für die anderen TDBGrids dient.

Basierend auf Ihrer Beschreibung benötigen Sie insgesamt zwei TClientDataSet-Komponenten und ein TDataset.
    1. Erstes TClientDataSet: Dieses TClientDataSet wird verwendet, um die Daten aus der XML-Datei zu laden und zu filtern, um nur die gewünschten Beiträge anzuzeigen. Es wird als Datenquelle für die erste TDBGrid verwendet.
    2. Zweites TClientDataSet: Dieses TClientDataSet wird verwendet, um die Messwerte für den ausgewählten Beitrag anzuzeigen. Es wird als Datenquelle für die zweite TDBGrid verwendet.
    3. TDataset für die Verbindung zur Datenbank: Dieses TDataset wird verwendet, um die gewünschten Daten direkt aus der Datenbank abzurufen. Es wird als Datenquelle für die vierte TDBGrid verwendet.
Die Struktur könnte etwa wie folgt aussehen:
    • Das erste TClientDataSet wird mit den Daten aus der XML-Datei gefüllt und gefiltert, um nur die gewünschten Beiträge anzuzeigen. Diese werden in der ersten TDBGrid angezeigt.
    • Wenn der Benutzer einen Beitrag in der ersten TDBGrid auswählt, werden die zugehörigen Messwerte aus dem zweiten TClientDataSet geladen und in der zweiten TDBGrid angezeigt.
    • Der Benutzer kann dann Messwerte aus der zweiten TDBGrid auswählen und sie per Drag & Drop in die dritte TDBGrid ziehen.
    • Die vierte TDBGrid zeigt gewisse Spalten aus der Datenbank an, die von einem separaten TDataset abgerufen werden.
Auf diese Weise haben Sie die erforderlichen Komponenten, um Ihre Anforderungen zu erfüllen.


Wenn das dritte TDBGrid lediglich als Drop-Ziel fungiert und keine eigene Datenquelle benötigt, können Sie es dennoch verwenden, um die Daten aus der zweiten TDBGrid anzuzeigen, nachdem der Benutzer sie dort platziert hat.
Sie können die Daten aus der zweiten TDBGrid einfach über die Drag & Drop-Funktion in das dritte TDBGrid ziehen. Da das dritte TDBGrid jedoch keine eigene Datenquelle hat, müssen Sie die Datenstruktur so gestalten, dass sie die gewünschte Ordnung widerspiegelt.
Hier sind einige Schritte, wie Sie vorgehen könnten:
    1. Wenn der Benutzer Daten aus der zweiten TDBGrid in das dritte TDBGrid zieht, können Sie Ereignisse wie OnDragOver und OnDragDrop verwenden, um die Daten zu verarbeiten und in das dritte TDBGrid einzufügen.
    2. Bevor Sie die Daten in das dritte TDBGrid einfügen, können Sie sicherstellen, dass sie die gewünschte Ordnung haben, z. B. indem Sie sicherstellen, dass die Daten bestimmte Spalten enthalten und dass sie in einer bestimmten Reihenfolge angeordnet sind.
    3. Sie können die Daten dann einfach in das dritte TDBGrid einfügen, ohne dass ein TClientDataSet oder TDataset benötigt wird, da das TDBGrid lediglich als Anzeigefläche für die Daten dient.
Auf diese Weise können Sie das dritte TDBGrid als Drop-Ziel verwenden und sicherstellen, dass die Daten, die dort platziert werden, die gewünschte Ordnung haben.

Um die Positionen der Zellen im dritten TDBGrid zu steuern und zu kontrollieren, müssen Sie sicherstellen, dass die Daten, die Sie in das TDBGrid einfügen, die gewünschte Struktur haben.
Angenommen, Sie möchten, dass jede Zeile im dritten TDBGrid vier Messreihen enthält, wobei jede Messreihe eine Spannung (Ux) und einen Strom (Ix) enthält. Sie könnten die Daten so strukturieren, dass jede Zeile im TDBGrid diese Informationen enthält, und dann die Spalten entsprechend benennen.
Hier ist ein Beispiel, wie Sie vorgehen könnten:
    1. Strukturieren Sie Ihre Daten entsprechend, sodass jede Zeile die Daten für vier Messreihen enthält, wobei jede Messreihe eine Spannung und einen Strom enthält.
    2. Legen Sie die Spaltennamen für das dritte TDBGrid fest, um die verschiedenen Messreihen zu repräsentieren. Sie könnten zum Beispiel Spalten mit Namen wie "U1", "I1", "U2", "I2" usw. festlegen.
    3. Wenn der Benutzer Daten aus der zweiten TDBGrid in das dritte TDBGrid zieht, fügen Sie die Daten entsprechend der gewünschten Struktur ein. Stellen Sie sicher, dass Sie die Daten so in das TDBGrid einfügen, dass sie den Spalten entsprechen, die Sie für jede Messreihe festgelegt haben.
    4. Verwenden Sie die Ereignisse des TDBGrid wie OnDragOver und OnDragDrop, um sicherzustellen, dass die Daten korrekt eingefügt werden und die gewünschte Struktur im dritten TDBGrid beibehalten wird.
Durch die strukturierte Organisation Ihrer Daten und die entsprechende Festlegung der Spalten im TDBGrid können Sie die Positionen der Zellen im dritten TDBGrid steuern und kontrollieren.


// Angenommen, auf die Zelle in Zeile 2 und Spalte 3 zugreifen:
int row = 2;
int col = 3;

// Stellen Sie sicher, dass die Zeile und Spalte innerhalb des gültigen Bereichs liegen:
if (row >= 0 && row < DBGrid1->RowCount && col >= 0 && col < DBGrid1->ColCount) {
    // Greifen Sie auf den Wert der Zelle zu und manipulieren Sie ihn:
    String cellValue = DBGrid1->Cells[col][row];
    
    // Manipulieren Sie den Wert der Zelle (zum Beispiel setzen Sie einen neuen Wert):
    DBGrid1->Cells[col][row] = "Neuer Wert";
} else {
    // Fehlerbehandlung für den Fall, dass die Zeile oder Spalte außerhalb des gültigen Bereichs liegt
    ShowMessage("Ungültige Zeile oder Spalte");
}
 RowCount gibt die Anzahl der Zeilen im TDBGrid an und ColCount gibt die Anzahl der Spalten an.
Sie können die Werte von row und col entsprechend ändern, um auf verschiedene Zellen zuzugreifen, und dann den Wert der Zelle lesen oder manipulieren, indem Sie auf die Cells-Eigenschaft des TDBGrid zugreifen. Beachten Sie, dass die Zeilen- und Spaltenindizes bei 0 beginnen.
Bitte beachten Sie, dass dies ein einfaches Beispiel ist, und je nach Ihren spezifischen Anforderungen und dem Datenmodell, das Sie verwenden, möglicherweise zusätzliche Schritte erforderlich sind.

Gibt es noch eine andere Art mit anderen Befehlen und Syntax in C++ bezüglich "// Angenommen, Sie möchten auf die Zelle in Zeile 2 und Spalte 3 zugreifen: int row = 2; int col = 3; // Stellen Sie sicher, dass die Zeile und Spalte innerhalb des gültigen Bereichs liegen: if (row >= 0 && row < DBGrid1->RowCount && col >= 0 && col < DBGrid1->ColCount) { // Greifen Sie auf den Wert der Zelle zu und manipulieren Sie ihn: String cellValue = DBGrid1->Cells[col][row]; // Manipulieren Sie den Wert der Zelle (zum Beispiel setzen Sie einen neuen Wert): DBGrid1->Cells[col][row] = "Neuer Wert"; } else { // Fehlerbehandlung für den Fall, dass die Zeile oder Spalte außerhalb des gültigen Bereichs liegt ShowMessage("Ungültige Zeile oder Spalte"); } "?

Beispiel, um auf eine Zelle in Zeile 2 und Spalte 3 zugreifen können:
cppCopy code
int row = 2;
int col = 3;

if (row >= 0 && row < DBGrid1->RowCount && col >= 0 && col < DBGrid1->ColCount) {
    // Greifen Sie auf den Wert der Zelle zu und manipulieren Sie ihn:
    String cellValue = DBGrid1->GetFieldValue(col, row);
    
    // Manipulieren Sie den Wert der Zelle (zum Beispiel setzen Sie einen neuen Wert):
    DBGrid1->SetFieldValue(col, row, "Neuer Wert");
} else {
    // Fehlerbehandlung für den Fall, dass die Zeile oder Spalte außerhalb des gültigen Bereichs liegt
    ShowMessage("Ungültige Zeile oder Spalte");
}
In diesem Beispiel wird GetFieldValue verwendet, um den Wert der Zelle in der angegebenen Zeile und Spalte abzurufen, und SetFieldValue wird verwendet, um den Wert einer Zelle zu setzen. Die Methode GetFieldValue erwartet die Spaltennummer als ersten Parameter und die Zeilennummer als zweiten Parameter.
 Spaltennummer bei 0 beginnt, während die Zeilennummer bei 1 beginnt.

//--------------------------------------------------------------------------------------------------------------------------------------

Kopie der Daten aus der Datenbank zu erstellen und sie einem TClientDataSet zur weiteren Verwendung in anderen TDBGrid-Komponenten zur Verfügung zu stellen, können Sie den folgenden Ansatz verwenden:
Angenommen,  haben eine Verbindung zu Ihrer Datenbank und einen TClientDataSet namens ClientDataSet1, der als Zwischenspeicher für die Daten aus der Datenbank dient:
cppCopy code
// Erstelle eine Verbindung zur Datenbank
TADOConnection *ADOConnection1 = new TADOConnection(this);
ADOConnection1->ConnectionString = "YourConnectionString";
ADOConnection1->Connected = true;

// Erstelle einen ClientDataSet und stellen Sie eine Verbindung zur Datenbank her
TClientDataSet *ClientDataSet1 = new TClientDataSet(this);
ClientDataSet1->ProviderName = "YourProviderName";
ClientDataSet1->CommandText = "SELECT * FROM YourTable";
ClientDataSet1->Active = true;

// Erstelle einen DataSource und binden Sie ihn an das ClientDataSet
TDataSource *DataSource1 = new TDataSource(this);
DataSource1->DataSet = ClientDataSet1;

// Verwende den ClientDataSet zum Kopieren der Daten
TClientDataSet *CopiedDataSet = new TClientDataSet(this);
CopiedDataSet->FieldDefs->Assign(ClientDataSet1->FieldDefs); // Kopieren Sie die Felddefinitionen

// Kopiere die Daten aus dem ClientDataSet in das Kopier-Dataset
ClientDataSet1->First();
while (!ClientDataSet1->Eof) {
    CopiedDataSet->Insert();
    for (int i = 0; i < ClientDataSet1->FieldCount; ++i) {
        CopiedDataSet->Fields->Fields[i]->Value = ClientDataSet1->Fields->Fields[i]->Value;
    }
    CopiedDataSet->Post();
    ClientDataSet1->Next();
}

// Verwenden Sie das Kopier-Dataset als Datenquelle für andere TDBGrids
DataSource1->DataSet = CopiedDataSet;
In diesem Beispiel wird zuerst eine Verbindung zur Datenbank hergestellt und ein TClientDataSet (ClientDataSet1) erstellt, das Daten aus einer Tabelle in der Datenbank lädt. Dann wird ein neues TClientDataSet (CopiedDataSet) erstellt, das die gleichen Felddefinitionen wie ClientDataSet1 hat.
Die Daten werden dann aus ClientDataSet1 in CopiedDataSet kopiert, indem jede Zeile von ClientDataSet1 durchlaufen wird und die entsprechenden Werte in CopiedDataSet eingefügt werden.
Schließlich wird das DataSource1-Objekt, das an ClientDataSet1 gebunden ist, an CopiedDataSet gebunden, so dass CopiedDataSet als Datenquelle für andere TDBGrid-Komponenten verwendet werden kann.
//------------------------------------------------------------------

CopiedDataSet->Insert(); for (int i = 0; i < ClientDataSet1->FieldCount; ++i) { CopiedDataSet->Fields->Fields[i]->Value = ClientDataSet1->Fields->Fields[i]->Value; } CopiedDataSet->Post(); ClientDataSet1->Next();" Bitte hier um genauere Erklärung.

Dieser Abschnitt des Codes ist dafür verantwortlich, die Daten aus ClientDataSet1 in CopiedDataSet zu kopieren. 
    1. CopiedDataSet->Insert();: Diese Zeile fügt eine neue Zeile in das CopiedDataSet ein. Dadurch wird eine neue Zeile erstellt, in die die Daten aus ClientDataSet1 kopiert werden können.
    2. for (int i = 0; i < ClientDataSet1->FieldCount; ++i) {: Diese Schleife durchläuft alle Felder in ClientDataSet1. FieldCount gibt die Anzahl der Felder in ClientDataSet1 an.
    3. CopiedDataSet->Fields->Fields[i]->Value = ClientDataSet1->Fields->Fields[i]->Value;: In dieser Zeile wird der Wert des aktuellen Felds in ClientDataSet1 auf das entsprechende Feld in CopiedDataSet kopiert. Fields gibt eine Liste aller Felder im TDataSet an, und [i] gibt das aktuelle Feld in der Schleife an. Value gibt den Wert des aktuellen Felds an.
    4. CopiedDataSet->Post();: Nachdem alle Felder kopiert wurden, wird Post() aufgerufen, um die aktuelle Zeile in CopiedDataSet zu bestätigen und zu speichern.
    5. ClientDataSet1->Next();: Mit diesem Befehl wird zum nächsten Datensatz in ClientDataSet1 übergegangen, um den Vorgang für die nächste Zeile zu wiederholen.
Zusammengefasst: Durch diese Schleife wird jede Zeile von ClientDataSet1 durchlaufen, und die Werte der Felder werden in eine neue Zeile von CopiedDataSet kopiert. Auf diese Weise werden alle Daten aus ClientDataSet1 in CopiedDataSet dupliziert.


Speicherlecks zu vermeiden, sicherstellen, dass dynamisch allokierten Speicher ordnungsgemäß freigeben, Im Falle von TClientDataSet wird der Speicher automatisch freigegeben, wenn die Instanzen der Objekte zerstört werden. Wenn alle dynamisch allokierten TClientDataSet-Objekte freigeben, wenn sie nicht mehr benötigt werden, vermeiden Speicherlecks.
Im Beispielcode wird ClientDataSet1 und CopiedDataSet als lokale Variablen im Konstruktor (oder einer Methode) erstellt. Wenn die Instanz der Klasse, die diese Variablen enthält, zerstört wird, werden auch diese Variablen zerstört, was dazu führt, dass der Speicher automatisch freigegeben wird.
 jedoch TClientDataSet-Objekte dynamisch auf dem Heap erstellen (mit dem new-Operator),  mit dem delete-Operator freigeben, wenn sie nicht mehr benötigt werden. Andernfalls entstehen Speicherlecks.
Zum Beispiel:
cppCopy code
// Dynamisch auf dem Heap erstellen
TClientDataSet *CopiedDataSet = new TClientDataSet(this);

// Speicher freigeben, wenn nicht mehr benötigt
delete CopiedDataSet;

//------------------------------------------------Neu 4 April----------------------
Wenn ich im VCL für ein Control dmDrag auf dmAutomatic setze brauche ich kein BeginnDrag aufzurufen richtig ?

Ja, das ist richtig. Wenn Sie das Drag-Mode-Eigenschaft eines Steuerelements in VCL auf dmAutomatic setzen, wird das Drag & Drop-Verhalten automatisch aktiviert, wenn der Benutzer den Mauszeiger über das Steuerelement zieht. Sie müssen kein explizites BeginDrag()-Ereignis aufrufen.
Wenn dmAutomatic festgelegt ist, wird das Drag & Drop-Verhalten des Steuerelements automatisch aktiviert, sobald der Benutzer die Maustaste drückt und die Maus über das Steuerelement zieht. In diesem Modus behandelt das Steuerelement Drag & Drop-Ereignisse intern und startet das Drag & Drop-Protokoll ohne zusätzliche Aufrufe von BeginDrag().

You
Das bedeutet dann brauche ich nur zu definieren wenn das DragundDrop mit dem Drop beendet wird. Richtig ? 
ChatGPT
ChatGPT
Genau, wenn Sie das Drag & Drop-Verhalten eines Steuerelements in VCL auf dmAutomatic setzen, müssen Sie sich nur um das Ereignis kümmern, das auftritt, wenn das Drag & Drop abgeschlossen ist, also das OnDragDrop-Ereignis.
Das OnDragDrop-Ereignis tritt auf, wenn der Benutzer ein Objekt per Drag & Drop auf das Steuerelement zieht und die Maustaste loslässt, um das Objekt dort fallen zu lassen. In diesem Ereignis können Sie dann den Code platzieren, der ausgeführt werden soll, wenn das Objekt erfolgreich abgelegt wurde.
Hier ist ein einfaches Beispiel:
cppCopy code
void __fastcall TForm1::FormCreate(TObject *Sender)
{
    // Setze das Drag-Mode-Eigenschaft des Steuerelements auf dmAutomatic
    MyControl->DragMode = dmAutomatic;
}

void __fastcall TForm1::MyControlDragDrop(TObject *Sender, TObject *Source, int X, int Y)
{
    // Code, der ausgeführt werden soll, wenn das Objekt abgelegt wurde
    // z.B. Verarbeiten des abgelegten Objekts
}
In diesem Beispiel wird das OnDragDrop-Ereignis für das Steuerelement MyControl definiert, das aufgerufen wird, wenn der Benutzer ein Objekt auf das Steuerelement zieht und die Maustaste loslässt. Innerhalb dieses Ereignisses können Sie dann den Code platzieren, der ausgeführt werden soll, wenn das Objekt erfolgreich abgelegt wurde.
MyControl->DragMode = dmManual; Was alles ist dann zu tum um ein DragUndDrop zu erreichen ?

Wenn Sie das Drag-Mode-Eigenschaft eines Steuerelements in VCL auf dmManual setzen, müssen Sie manuell den Beginn und das Ende des Drag & Drop-Vorgangs verwalten. Hier ist eine grundlegende Anleitung dazu:
    1. BeginDrag-Ereignis: Sie müssen ein Ereignis behandeln, das auftritt, wenn der Benutzer das Drag & Drop beginnt. Dies wird normalerweise durch Klicken und Ziehen des Mauszeigers ausgelöst. Sie können das OnMouseDown-Ereignis des Steuerelements verwenden, um den Drag & Drop-Vorgang zu starten.
    2. DragOver-Ereignis: Während der Benutzer das Objekt zieht, tritt das OnDragOver-Ereignis auf, während sich der Mauszeiger über dem Steuerelement befindet. Hier können Sie den Drag & Drop-Vorgang anpassen, z.B. durch Ändern des Mauszeigers oder Anzeigen eines visuellen Feedbacks.
    3. DragDrop-Ereignis: Wenn der Benutzer das Objekt loslässt und es fallen lässt, tritt das OnDragDrop-Ereignis auf. Hier können Sie den Code platzieren, der ausgeführt werden soll, wenn das Objekt erfolgreich abgelegt wurde.
    4. EndDrag-Methode (optional): Nachdem das Drag & Drop abgeschlossen ist, können Sie die EndDrag-Methode verwenden, um den Drag & Drop-Vorgang zu beenden und den internen Zustand des Steuerelements zurückzusetzen.
Hier ist ein einfaches Beispiel, wie Sie diese Ereignisse behandeln können:
cppCopy code
void __fastcall TForm1::MyControlMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
    if (Button == mbLeft) {
        MyControl->BeginDrag(true);
    }
}

void __fastcall TForm1::MyControlDragOver(TObject *Sender, TObject *Source, int X, int Y, TDragState State, bool &Accept)
{
    // Anpassen des visuellen Feedbacks während des Ziehens
    // z.B. Ändern des Mauszeigers
    MyControl->Cursor = crDrag;
}

void __fastcall TForm1::MyControlDragDrop(TObject *Sender, TObject *Source, int X, int Y)
{
    // Code, der ausgeführt werden soll, wenn das Objekt abgelegt wurde
    // z.B. Verarbeiten des abgelegten Objekts
}

void __fastcall TForm1::MyControlEndDrag(TObject *Sender, TObject *Target, int X, int Y)
{
    // Aufrufen der EndDrag-Methode, um den Drag & Drop-Vorgang zu beenden
    MyControl->EndDrag(true);
}
In diesem Beispiel behandeln die Ereignisse OnMouseDown, OnDragOver, OnDragDrop und EndDrag, um den Drag & Drop-Vorgang zu verwalten, wenn das Drag-Mode-Eigenschaft auf dmManual gesetzt ist.

//-----------------------------------------6 April 2024-------------------------------------------
TColumn* ColumnByName(TDBGrid* Grid, const AnsiString& Name)
{
    for (int i = 0; i < Grid->Columns->Count; i++)
    {
        if (Grid->Columns->Items[i]->FieldName == Name)
        {
            return Grid->Columns->Items[i];
        }
    }
    return nullptr;
}

--------

if (ColumnByName(DBGrid1, "SpaltenName") != nullptr)
{
    // Der Spaltenname existiert bereits
}
else
{
    // Der Spaltenname existiert nicht
}


________

void __fastcall TForm1::DBGrid1EndDrag(TObject *Sender, TObject *Target, int X, int Y)
{
    // Angenommen, draggedColumn ist der Name der Spalte, die der Benutzer in das Grid gezogen hat
    std::string draggedColumn = ...;

    // Überprüfen, ob die Spalte in Ihrem Vektor vorhanden ist
    auto it = std::find_if(vector.begin(), vector.end(), &draggedColumn
    {
        return pair.first == draggedColumn;
    });

    if (it != vector.end())
    {
        // Wenn die Spalte vorhanden ist, füllen Sie die Spalte mit den Werten aus Ihrem Vektor
        cds->Open();
        for (const auto& pair : vector)
        {
            if (pair.first == draggedColumn)
            {
                cds->Append();
                cds->FieldByName(draggedColumn.c_str())->AsString = pair.second.c_str();
                cds->Post();
            }
        }
        cds->First();
    }
}
________

void __fastcall TForm1::DBGrid1EndDrag(TObject *Sender, TObject *Target, int X, int Y)
{
    // Angenommen, draggedColumn ist der Name der Spalte, die der Benutzer in das Grid gezogen hat
    std::string draggedColumn = ...;

    // Überprüfen, ob die Spalte in Ihrem Vektor vorhanden ist
    std::vector<std::pair<std::string, std::string> >::iterator it;
    for (it = vector.begin(); it != vector.end(); ++it)
    {
        if (it->first == draggedColumn)
        {
            break;
        }
    }

    if (it != vector.end())
    {
        // Wenn die Spalte vorhanden ist, fülle die Spalte mit den Werten aus Ihrem Vektor
        cds->Open();
        for (std::vector<std::pair<std::string, std::string> >::iterator pair = vector.begin(); pair != vector.end(); ++pair)
        {
            if (pair->first == draggedColumn)
            {
                cds->Append();
                cds->FieldByName(draggedColumn.c_str())->AsString = pair->second.c_str();
                cds->Post();
            }
        }
        cds->First();
    }
}
_______

void __fastcall TForm1::DBGrid1CellClick(TColumn *Column)
{
    // Speicher den Namen der ausgewählten Spalte
    draggedColumn = Column->FieldName.c_str();
}

_______

void __fastcall TForm1::DBGrid1EndDrag(TObject *Sender, TObject *Target, int X, int Y)
{
    // Überprüfen, ob die Spalte in Ihrem Vektor vorhanden ist
    std::vector<std::pair<std::string, std::string> >::iterator it;
    for (it = vector.begin(); it != vector.end(); ++it)
    {
        if (it->first == draggedColumn)
        {
            break;
        }
    }

    if (it != vector.end())
    {
        // Wenn die Spalte vorhanden ist, füllen die Spalte mit den Werten aus Ihrem Vektor
        cds->Open();
        for (std::vector<std::pair<std::string, std::string> >::iterator pair = vector.begin(); pair != vector.end(); ++pair)
        {
            if (pair->first == draggedColumn)
            {
                cds->Append();
                cds->FieldByName(draggedColumn.c_str())->AsString = pair->second.c_str();
                cds->Post();
            }
        }
        cds->First();
    }
}
______
______

class TMyButton : public TButton
{
public:
    __fastcall TMyButton(TComponent* Owner) : TButton(Owner)
    {
        // benutzerdefinierte Eigenschaften für Ihren Button festlegen
        this->Caption = "Mein Button";
        this->Width = 150;
        this->Height = 50;
    }
};

//<<____
void __fastcall TForm5::UpdateUserGrid()
{
	if(!ClientDataSet3->Active)
	{
		ClientDataSet3->CreateDataSet();
	}

	if(xmlProcess)
			{
				DBGridUserChoice->DataSource->DataSet->Next();
				ClientDataSet3->Append(); //Nur hier hinein

				std::vector<std::pair<std::wstring, std::wstring> > dataUserChoice = xmlProcess->GetXMLInfo4UserChoice();
				//--------------------------------------------

				std::vector<std::pair<std::wstring, std::wstring> > dataXML = xmlProcess->GetXMLInfo();
				//Schleife der Überschrift
				for(size_t i = 0; i < dataUserChoice.size();++i )
				{
					const std::pair < std::wstring, std::wstring>& pairUserChoice = dataUserChoice[i];

					//Nun schauen wo überall gleiche Userchoice als Einheit
					for(size_t j = 0; j < dataXML.size()-3; ++j)
					{
						const std::pair < std::wstring, std::wstring>& pairOfXML = dataXML[j];

					std::wstring w1User = pairUserChoice.first;
					std::wstring w2User = pairUserChoice.second; //ValueUser
					std::wstring w3XML = pairOfXML.first; //CaptionOfColum
					std::wstring w4XML = pairOfXML.second; //ValueXML
					if((w1User != L"") && (w1User == w3XML)) //std::wcscmp(w1 ,w2) == 0)
						{
								//DBGridUserChoice->DataSource->DataSet->Next();
								//ClientDataSet3->FieldByName(pair.first.c_str())->AsString = pair.second.c_str();
								ClientDataSet3->FieldByName(pairUserChoice.first.c_str())->AsString = pairOfXML.second.c_str();
								const std::pair < std::wstring, std::wstring>& pairOfXML1 = dataXML[j+1];
								ClientDataSet3->FieldByName(pairUserChoice.first.c_str())->AsString = pairOfXML.second.c_str();

								const std::pair < std::wstring, std::wstring>& pairOfXML2 = dataXML[j+2];
								//DBGridUserChoice->DataSource->DataSet->Next();
								//ClientDataSet3->Append();
								ClientDataSet3->FieldByName(pairUserChoice.first.c_str())->AsString = L"Ueberschreibe" ;// + pairOfXML.second.c_str();
								//ClientDataSet3->Post();
						}

					}


				}

				//--------------------------------------------
				ClientDataSet3->Post(); //Nur hier hinein
			}


}

//<<<<<_______________________________
fastcall TForm5::TForm5(TComponent* Owner)
	: TForm(Owner)
{
	onesCDS3Create = false;
	eventChoosed = false;
	dbGridXMLin = false;
	fromDBGrid4XMLCard_Item = false;
	OpenTextFileDialog1 = new TOpenTextFileDialog(this);
	OpenTextFileDialog1->InitialDir = GetCurrentDir();

	//Nocfh CancelWert einbringen
	if (OpenTextFileDialog1->Execute())
	{
		//ShowMessage("Datei ausgewählt: " + OpenTextFileDialog1->FileName);
	}

	UnicodeString ustr = OpenTextFileDialog1->FileName;
	delete OpenTextFileDialog1;          //Ok wenn
	DBGridUserChoice->Cursor = crHandPoint;

	Memo1->ReadOnly = true;
	Memo1->Clear();
	clickedRow = 0;
	countUserWish = 0;

	if(!ustr.IsEmpty())
	{
		xmlProcess = NULL;
		xmlProcess = new XMLData();

		this->BorderStyle = bsDialog;


		std::wstring wstr(ustr.w_str());

		DataSource1->DataSet = ClientDataSet1;
		DBGrid4XMLin->DataSource = DataSource1;
		DBGrid4XMLin->ReadOnly = true;
		DBGrid4XMLin->DefaultDrawing = false;

		ClientDataSet1->FieldDefs->Clear();
		ClientDataSet1->FieldDefs->Add("Name", ftString, 50);
		ClientDataSet1->FieldDefs->Add("Datum/Uhrzeit", ftString, 255);

		ClientDataSet1->CreateDataSet();
		//Das zweite
		DataSource2->DataSet = ClientDataSet2;
		DBGrid4XMLCard_Item->DataSource = DataSource2;
		DBGrid4XMLin->ReadOnly = false; //true; RR142

		ClientDataSet2->FieldDefs->Clear();
		ClientDataSet2->FieldDefs->Add("Name der Messgroesse", ftString, 50);
		ClientDataSet2->FieldDefs->Add("Wert mit Einheit", ftString, 255);

		ClientDataSet2->CreateDataSet();

		//Das dritte
		DataSource3->DataSet = ClientDataSet3;
		DBGridUserChoice->DataSource = DataSource3;
		DBGridUserChoice->ReadOnly = true;  //prüfen ob evntuell Probleme mit Dund Drop

		ClientDataSet3->FieldDefs->Clear();

		xmlProcess->LoadXMLDocument(wstr);

		try
		{
			XML2Grid(xmlProcess);
		}
			catch (const Exception &e)
		{
			ShowMessage("Beim einlesen der XML-Daten. An Position" + e.Message);
			if(xmlProcess) {
				delete xmlProcess;
				xmlProcess = NULL;
			}
		}

	}
	else
	{
		ShowMessage("Sie haben die Aktion abgebrochen. Ohne die Wahl einer XML-Datei werden keine Daten geladen");
		//Am besten auch die Form abbauen oder Button File Dialog mal sehen
	}
}


void __fastcall TForm5::SBMouseEnterUserGrid(TObject *Sender)
{
	if(fromDBGrid4XMLCard_Item == true)
	{
		fromDBGrid4XMLCard_Item = false;
		NewColumnName();
		UpdateUserGrid();
	}
}

void __fastcall TForm5::NewColumnName()
{
	bool columnNameIsDouble = false;

	AnsiString clickleft = DBGrid4XMLCard_Item->Columns->Items[0]->Field->AsString;
	AnsiString clickright = DBGrid4XMLCard_Item->Columns->Items[1]->Field->AsString;
	//prüfen ob schon mal gewählt wurde
		std::vector<std::pair<std::wstring, std::wstring> > dataColumName = xmlProcess->GetXMLInfo4UserChoice();
		for(size_t j = 0; j < dataColumName.size(); ++j)
		{
			const std::pair < std::wstring, std::wstring>& pair = dataColumName[j];
			const std::wstring wstr = pair.first;

			if((clickleft != L"") && (NS_TForm5::AnsiToWide(clickleft) == wstr))
			{
				ShowMessage("Der Spaltenname existiert schon");
				columnNameIsDouble = true;
			}

		}

		//prüfen ob schon mal gewählt wurde
		if(ClientDataSet3->Active)
		{
			//ShowMessage("CLientDataSet is Active");
			ClientDataSet3->Close();
		}



		if(!columnNameIsDouble)
		{
			//Info was der User anklickt
			std::pair<std::wstring, std::wstring> info(NS_TForm5::AnsiToWide(clickleft), NS_TForm5::AnsiToWide(clickright)); //RRR42
			xmlProcess->xmlInfo4UserChoice.push_back(info);
			ClientDataSet3->FieldDefs->Add(clickleft, ftString, 12);

		}

			ClientDataSet3->CreateDataSet();
			ClientDataSet3->FieldDefs->Update();
			DBGridUserChoice->Refresh();
			ClientDataSet3->Open();

}

//Achtung Append und Post aussen
void __fastcall TForm5::UpdateUserGrid()
{
	if(xmlProcess)
			{
				std::vector<std::pair<std::wstring, std::wstring> > dataUserChoice = xmlProcess->GetXMLInfo4UserChoice();

				std::vector<std::pair<std::wstring, std::wstring> > dataXML = xmlProcess->GetXMLInfo();
				//Schleife der Überschrift
				for(size_t i = 0; i < dataUserChoice.size();++i )
				{
					const std::pair < std::wstring, std::wstring>& pairUserChoice = dataUserChoice[i];

					//Nun schauen wo überall gleiche Userchoice als Einheit
					for(size_t j = 0; j < dataXML.size(); ++j)
					{
						const std::pair < std::wstring, std::wstring>& pairOfXML = dataXML[j];

						std::wstring w1User = pairUserChoice.first;
						std::wstring w2User = pairUserChoice.second; //ValueUser
						std::wstring w3XML = pairOfXML.first; //CaptionOfColum
						std::wstring w4XML = pairOfXML.second; //ValueXML
						if((w1User != L"") && (w1User == w3XML)) //std::wcscmp(w1 ,w2) == 0)
						{
								ClientDataSet3->Append();
								//ClientDataSet3->Edit();	//schreibt auf der Stelle geht bzw fügt dazu

								ClientDataSet3->FieldByName(pairUserChoice.first.c_str())->AsString = pairOfXML.second.c_str();
								ClientDataSet3->Post();
						}

					}

					ClientDataSet3->RecNo = 1;
					//ClientDataSet3->First();


				}
				ClientDataSet3->FieldDefs->Update();
				DBGridUserChoice->Refresh();
			}


}



